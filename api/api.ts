/* tslint:disable */
/* eslint-disable */
/**
 * RateManu
 * API documentation
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface CommentCollectionResponse
 */
export interface CommentCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof CommentCollectionResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<CommentResponse>}
     * @memberof CommentCollectionResponse
     */
    'items': Array<CommentResponse>;
}
/**
 * 
 * @export
 * @interface CommentResponse
 */
export interface CommentResponse {
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface ConfirmUserRegistrationRequest
 */
export interface ConfirmUserRegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof ConfirmUserRegistrationRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface CreateCommentRequest
 */
export interface CreateCommentRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateCommentRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CreateFoodIngredientRequest
 */
export interface CreateFoodIngredientRequest {
    /**
     * Will be generated if not provided
     * @type {string}
     * @memberof CreateFoodIngredientRequest
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFoodIngredientRequest
     */
    'ingredientId': string;
    /**
     * If not provided, default unit will be used
     * @type {string}
     * @memberof CreateFoodIngredientRequest
     */
    'unit'?: CreateFoodIngredientRequestUnitEnum | null;
    /**
     * Numeric value. Will be converted to floating point if needed.
     * @type {number}
     * @memberof CreateFoodIngredientRequest
     */
    'amount': number;
}

export const CreateFoodIngredientRequestUnitEnum = {
    G: 'g',
    Kg: 'kg',
    L: 'l',
    Ml: 'ml',
    Pcs: 'pcs'
} as const;

export type CreateFoodIngredientRequestUnitEnum = typeof CreateFoodIngredientRequestUnitEnum[keyof typeof CreateFoodIngredientRequestUnitEnum];

/**
 * 
 * @export
 * @interface CreateFoodIngredientsRequest
 */
export interface CreateFoodIngredientsRequest {
    /**
     * List of food ingredients
     * @type {Array<CreateFoodIngredientRequest>}
     * @memberof CreateFoodIngredientsRequest
     */
    'ingredients': Array<CreateFoodIngredientRequest>;
}
/**
 * 
 * @export
 * @interface CreateFoodRequest
 */
export interface CreateFoodRequest {
    /**
     * Will be generated if not provided
     * @type {string}
     * @memberof CreateFoodRequest
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateFoodRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateFoodRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface CreateIngredientRequest
 */
export interface CreateIngredientRequest {
    /**
     * Will be generated if not provided
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    'id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    'defaultUnit': CreateIngredientRequestDefaultUnitEnum;
    /**
     * Primary group will be used be generated if not provided
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    'groupId'?: string | null;
}

export const CreateIngredientRequestDefaultUnitEnum = {
    G: 'g',
    Kg: 'kg',
    L: 'l',
    Ml: 'ml',
    Pcs: 'pcs'
} as const;

export type CreateIngredientRequestDefaultUnitEnum = typeof CreateIngredientRequestDefaultUnitEnum[keyof typeof CreateIngredientRequestDefaultUnitEnum];

/**
 * 
 * @export
 * @interface Filter
 */
export interface Filter {
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'entity': string;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'propertyName': string;
    /**
     * 
     * @type {string}
     * @memberof Filter
     */
    'operator': string;
    /**
     * 
     * @type {FilterValue}
     * @memberof Filter
     */
    'value': FilterValue;
}
/**
 * @type FilterValue
 * @export
 */
export type FilterValue = boolean | number | string;

/**
 * 
 * @export
 * @interface FoodCollectionResponse
 */
export interface FoodCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof FoodCollectionResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<FoodResponse>}
     * @memberof FoodCollectionResponse
     */
    'items': Array<FoodResponse>;
}
/**
 * 
 * @export
 * @interface FoodIngredientResponse
 */
export interface FoodIngredientResponse {
    /**
     * Unique identifier of the food ingredient
     * @type {string}
     * @memberof FoodIngredientResponse
     */
    'id': string;
    /**
     * Unique identifier of the food
     * @type {string}
     * @memberof FoodIngredientResponse
     */
    'foodId': string;
    /**
     * Unique identifier of the ingredient
     * @type {string}
     * @memberof FoodIngredientResponse
     */
    'ingredientId': string;
    /**
     * 
     * @type {IngredientResponse}
     * @memberof FoodIngredientResponse
     */
    'ingredient': IngredientResponse;
    /**
     * Amount of the ingredient
     * @type {number}
     * @memberof FoodIngredientResponse
     */
    'amount': number;
    /**
     * Unit of measurement for the ingredient amount
     * @type {string}
     * @memberof FoodIngredientResponse
     */
    'unit': string;
}
/**
 * 
 * @export
 * @interface FoodResponse
 */
export interface FoodResponse {
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'group': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'updatedAt': string;
    /**
     * 
     * @type {string}
     * @memberof FoodResponse
     */
    'image'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodResponse
     */
    'averageRating': FoodResponseAverageRatingEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof FoodResponse
     */
    'ratings': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FoodResponse
     */
    'comments': Array<string>;
    /**
     * 
     * @type {RatingResponse}
     * @memberof FoodResponse
     */
    'personalRating'?: RatingResponse | null;
}

export const FoodResponseAverageRatingEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type FoodResponseAverageRatingEnum = typeof FoodResponseAverageRatingEnum[keyof typeof FoodResponseAverageRatingEnum];

/**
 * 
 * @export
 * @interface GroupMemberResponse
 */
export interface GroupMemberResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupMemberResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberResponse
     */
    'email': string;
    /**
     * 
     * @type {Status}
     * @memberof GroupMemberResponse
     */
    'status': Status;
    /**
     * 
     * @type {string}
     * @memberof GroupMemberResponse
     */
    'name'?: string | null;
}


/**
 * 
 * @export
 * @interface GroupResponse
 */
export interface GroupResponse {
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupResponse
     */
    'name': string;
    /**
     * 
     * @type {Role}
     * @memberof GroupResponse
     */
    'role': Role;
    /**
     * 
     * @type {Array<GroupMemberResponse>}
     * @memberof GroupResponse
     */
    'members': Array<GroupMemberResponse>;
}


/**
 * 
 * @export
 * @interface IngredientCollectionResponse
 */
export interface IngredientCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof IngredientCollectionResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<IngredientResponse>}
     * @memberof IngredientCollectionResponse
     */
    'items': Array<IngredientResponse>;
}
/**
 * 
 * @export
 * @interface IngredientResponse
 */
export interface IngredientResponse {
    /**
     * 
     * @type {string}
     * @memberof IngredientResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof IngredientResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IngredientResponse
     */
    'defaultUnit': IngredientResponseDefaultUnitEnum;
}

export const IngredientResponseDefaultUnitEnum = {
    G: 'g',
    Kg: 'kg',
    L: 'l',
    Ml: 'ml',
    Pcs: 'pcs'
} as const;

export type IngredientResponseDefaultUnitEnum = typeof IngredientResponseDefaultUnitEnum[keyof typeof IngredientResponseDefaultUnitEnum];

/**
 * 
 * @export
 * @interface InviteUserRequest
 */
export interface InviteUserRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof InviteUserRequest
     */
    'group': string;
}
/**
 * 
 * @export
 * @interface LoginCheck200Response
 */
export interface LoginCheck200Response {
    /**
     * 
     * @type {string}
     * @memberof LoginCheck200Response
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCheck200Response
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface LoginCheckRequest
 */
export interface LoginCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginCheckRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginCheckRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface PersonalRatingResponse
 */
export interface PersonalRatingResponse {
    /**
     * 
     * @type {string}
     * @memberof PersonalRatingResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PersonalRatingResponse
     */
    'food': string;
    /**
     * 
     * @type {number}
     * @memberof PersonalRatingResponse
     */
    'rating': PersonalRatingResponseRatingEnum;
    /**
     * 
     * @type {string}
     * @memberof PersonalRatingResponse
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof PersonalRatingResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof PersonalRatingResponse
     */
    'updatedAt': string;
}

export const PersonalRatingResponseRatingEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type PersonalRatingResponseRatingEnum = typeof PersonalRatingResponseRatingEnum[keyof typeof PersonalRatingResponseRatingEnum];

/**
 * 
 * @export
 * @interface RatingCollectionResponse
 */
export interface RatingCollectionResponse {
    /**
     * 
     * @type {number}
     * @memberof RatingCollectionResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<RatingResponse>}
     * @memberof RatingCollectionResponse
     */
    'items': Array<RatingResponse>;
}
/**
 * 
 * @export
 * @interface RatingResponse
 */
export interface RatingResponse {
    /**
     * 
     * @type {string}
     * @memberof RatingResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof RatingResponse
     */
    'food': string;
    /**
     * 
     * @type {number}
     * @memberof RatingResponse
     */
    'rating': RatingResponseRatingEnum;
    /**
     * 
     * @type {GroupMemberResponse}
     * @memberof RatingResponse
     */
    'createdBy': GroupMemberResponse;
    /**
     * 
     * @type {string}
     * @memberof RatingResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof RatingResponse
     */
    'updatedAt': string;
}

export const RatingResponseRatingEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
} as const;

export type RatingResponseRatingEnum = typeof RatingResponseRatingEnum[keyof typeof RatingResponseRatingEnum];

/**
 * 
 * @export
 * @interface RegisterUserRequest
 */
export interface RegisterUserRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterUserRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Role = {
    Member: 'member',
    Owner: 'owner'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface SearchQueryString
 */
export interface SearchQueryString {
    /**
     * 
     * @type {number}
     * @memberof SearchQueryString
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof SearchQueryString
     */
    'limit'?: number;
    /**
     * 
     * @type {Array<Sorting>}
     * @memberof SearchQueryString
     */
    'sorting'?: Array<Sorting>;
    /**
     * 
     * @type {Array<Filter>}
     * @memberof SearchQueryString
     */
    'filter'?: Array<Filter>;
}
/**
 * 
 * @export
 * @interface Sorting
 */
export interface Sorting {
    /**
     * 
     * @type {string}
     * @memberof Sorting
     */
    'propertyName': string;
    /**
     * 
     * @type {string}
     * @memberof Sorting
     */
    'direction': SortingDirectionEnum;
}

export const SortingDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortingDirectionEnum = typeof SortingDirectionEnum[keyof typeof SortingDirectionEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const Status = {
    Active: 'active',
    Inactive: 'inactive',
    PendingRegistration: 'pending_registration'
} as const;

export type Status = typeof Status[keyof typeof Status];


/**
 * 
 * @export
 * @interface TokenRefreshRequest
 */
export interface TokenRefreshRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRefreshRequest
     */
    'refresh_token': string;
}
/**
 * 
 * @export
 * @interface UpdateFoodRequest
 */
export interface UpdateFoodRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFoodRequest
     */
    'description'?: string | null;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface UpsertRatingRequest
 */
export interface UpsertRatingRequest {
    /**
     * 
     * @type {string}
     * @memberof UpsertRatingRequest
     */
    'food': string;
    /**
     * 
     * @type {number}
     * @memberof UpsertRatingRequest
     */
    'rating': number;
}
/**
 * 
 * @export
 * @interface UserGroupsResponse
 */
export interface UserGroupsResponse {
    /**
     * 
     * @type {number}
     * @memberof UserGroupsResponse
     */
    'count': number;
    /**
     * 
     * @type {Array<GroupResponse>}
     * @memberof UserGroupsResponse
     */
    'items': Array<GroupResponse>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * 
     * @type {Status}
     * @memberof UserResponse
     */
    'status': Status;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'groups': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'name'?: string | null;
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ConfirmUserRegistrationRequest} confirmUserRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmRegistration: async (confirmUserRegistrationRequest: ConfirmUserRegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'confirmUserRegistrationRequest' is not null or undefined
            assertParamExists('confirmRegistration', 'confirmUserRegistrationRequest', confirmUserRegistrationRequest)
            const localVarPath = `/api/authentication/confirm-registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(confirmUserRegistrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginCheckRequest} loginCheckRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheck: async (loginCheckRequest: LoginCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginCheckRequest' is not null or undefined
            assertParamExists('loginCheck', 'loginCheckRequest', loginCheckRequest)
            const localVarPath = `/api/login_check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerUserRequest: RegisterUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserRequest' is not null or undefined
            assertParamExists('register', 'registerUserRequest', registerUserRequest)
            const localVarPath = `/api/authentication/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {TokenRefreshRequest} [tokenRefreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefresh: async (tokenRefreshRequest?: TokenRefreshRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefreshRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserRegistrationRequest} confirmUserRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmRegistration(confirmUserRegistrationRequest: ConfirmUserRegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmRegistration(confirmUserRegistrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.confirmRegistration']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LoginCheckRequest} loginCheckRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginCheck(loginCheckRequest: LoginCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginCheck(loginCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginCheck']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {TokenRefreshRequest} [tokenRefreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenRefresh(tokenRefreshRequest?: TokenRefreshRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginCheck200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenRefresh(tokenRefreshRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.tokenRefresh']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {ConfirmUserRegistrationRequest} confirmUserRegistrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmRegistration(confirmUserRegistrationRequest: ConfirmUserRegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirmRegistration(confirmUserRegistrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginCheckRequest} loginCheckRequest User credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginCheck(loginCheckRequest: LoginCheckRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginCheck200Response> {
            return localVarFp.loginCheck(loginCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegisterUserRequest} registerUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.register(registerUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {TokenRefreshRequest} [tokenRefreshRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenRefresh(tokenRefreshRequest?: TokenRefreshRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginCheck200Response> {
            return localVarFp.tokenRefresh(tokenRefreshRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {ConfirmUserRegistrationRequest} confirmUserRegistrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public confirmRegistration(confirmUserRegistrationRequest: ConfirmUserRegistrationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirmRegistration(confirmUserRegistrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginCheckRequest} loginCheckRequest User credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginCheck(loginCheckRequest: LoginCheckRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginCheck(loginCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegisterUserRequest} registerUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(registerUserRequest: RegisterUserRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(registerUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TokenRefreshRequest} [tokenRefreshRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public tokenRefresh(tokenRefreshRequest?: TokenRefreshRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).tokenRefresh(tokenRefreshRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodApi - axios parameter creator
 * @export
 */
export const FoodApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateFoodRequest} createFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCreate: async (createFoodRequest: CreateFoodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFoodRequest' is not null or undefined
            assertParamExists('foodCreate', 'createFoodRequest', createFoodRequest)
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFoodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodDelete', 'id', id)
            const localVarPath = `/api/food/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodGet', 'id', id)
            const localVarPath = `/api/food/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodSearch: async (offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorting) {
                localVarQueryParameter['sorting[]'] = sorting;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {UpdateFoodRequest} updateFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodUpdate: async (id: string, updateFoodRequest: UpdateFoodRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodUpdate', 'id', id)
            // verify required parameter 'updateFoodRequest' is not null or undefined
            assertParamExists('foodUpdate', 'updateFoodRequest', updateFoodRequest)
            const localVarPath = `/api/food/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFoodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodApi - functional programming interface
 * @export
 */
export const FoodApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateFoodRequest} createFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodCreate(createFoodRequest: CreateFoodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodCreate(createFoodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.foodCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.foodDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.foodGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodSearch(offset, limit, sorting, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.foodSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {UpdateFoodRequest} updateFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodUpdate(id: string, updateFoodRequest: UpdateFoodRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodUpdate(id, updateFoodRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodApi.foodUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodApi - factory interface
 * @export
 */
export const FoodApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateFoodRequest} createFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCreate(createFoodRequest: CreateFoodRequest, options?: RawAxiosRequestConfig): AxiosPromise<FoodResponse> {
            return localVarFp.foodCreate(createFoodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.foodDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FoodResponse> {
            return localVarFp.foodGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig): AxiosPromise<FoodCollectionResponse> {
            return localVarFp.foodSearch(offset, limit, sorting, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the food
         * @param {UpdateFoodRequest} updateFoodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodUpdate(id: string, updateFoodRequest: UpdateFoodRequest, options?: RawAxiosRequestConfig): AxiosPromise<FoodResponse> {
            return localVarFp.foodUpdate(id, updateFoodRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodApi - object-oriented interface
 * @export
 * @class FoodApi
 * @extends {BaseAPI}
 */
export class FoodApi extends BaseAPI {
    /**
     * 
     * @param {CreateFoodRequest} createFoodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public foodCreate(createFoodRequest: CreateFoodRequest, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).foodCreate(createFoodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The ID of the food
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public foodDelete(id: string, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).foodDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The ID of the food
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public foodGet(id: string, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).foodGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<Sorting>} [sorting] 
     * @param {Array<Filter>} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public foodSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).foodSearch(offset, limit, sorting, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The ID of the food
     * @param {UpdateFoodRequest} updateFoodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodApi
     */
    public foodUpdate(id: string, updateFoodRequest: UpdateFoodRequest, options?: RawAxiosRequestConfig) {
        return FoodApiFp(this.configuration).foodUpdate(id, updateFoodRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodCommentsApi - axios parameter creator
 * @export
 */
export const FoodCommentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCommentsCreate: async (id: string, createCommentRequest: CreateCommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodCommentsCreate', 'id', id)
            // verify required parameter 'createCommentRequest' is not null or undefined
            assertParamExists('foodCommentsCreate', 'createCommentRequest', createCommentRequest)
            const localVarPath = `/api/food/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCommentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCommentsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodCommentsGet', 'id', id)
            const localVarPath = `/api/food/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodCommentsApi - functional programming interface
 * @export
 */
export const FoodCommentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodCommentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodCommentsCreate(id: string, createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodCommentsCreate(id, createCommentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodCommentsApi.foodCommentsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodCommentsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommentCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodCommentsGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodCommentsApi.foodCommentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodCommentsApi - factory interface
 * @export
 */
export const FoodCommentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodCommentsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {CreateCommentRequest} createCommentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCommentsCreate(id: string, createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<CommentResponse> {
            return localVarFp.foodCommentsCreate(id, createCommentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodCommentsGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CommentCollectionResponse> {
            return localVarFp.foodCommentsGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodCommentsApi - object-oriented interface
 * @export
 * @class FoodCommentsApi
 * @extends {BaseAPI}
 */
export class FoodCommentsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {CreateCommentRequest} createCommentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodCommentsApi
     */
    public foodCommentsCreate(id: string, createCommentRequest: CreateCommentRequest, options?: RawAxiosRequestConfig) {
        return FoodCommentsApiFp(this.configuration).foodCommentsCreate(id, createCommentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodCommentsApi
     */
    public foodCommentsGet(id: string, options?: RawAxiosRequestConfig) {
        return FoodCommentsApiFp(this.configuration).foodCommentsGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodImagesApi - axios parameter creator
 * @export
 */
export const FoodImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id The ID of the food
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodImagesUpdate: async (id: string, image?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('foodImagesUpdate', 'id', id)
            const localVarPath = `/api/food/{id}/update-image`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodImagesApi - functional programming interface
 * @export
 */
export const FoodImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodImagesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id The ID of the food
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodImagesUpdate(id: string, image?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodImagesUpdate(id, image, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodImagesApi.foodImagesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodImagesApi - factory interface
 * @export
 */
export const FoodImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodImagesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id The ID of the food
         * @param {File} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodImagesUpdate(id: string, image?: File, options?: RawAxiosRequestConfig): AxiosPromise<FoodResponse> {
            return localVarFp.foodImagesUpdate(id, image, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodImagesApi - object-oriented interface
 * @export
 * @class FoodImagesApi
 * @extends {BaseAPI}
 */
export class FoodImagesApi extends BaseAPI {
    /**
     * 
     * @param {string} id The ID of the food
     * @param {File} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodImagesApi
     */
    public foodImagesUpdate(id: string, image?: File, options?: RawAxiosRequestConfig) {
        return FoodImagesApiFp(this.configuration).foodImagesUpdate(id, image, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodIngredientsApi - axios parameter creator
 * @export
 */
export const FoodIngredientsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {CreateFoodIngredientsRequest} createFoodIngredientsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodIngredientsAdd: async (foodId: string, createFoodIngredientsRequest: CreateFoodIngredientsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodId' is not null or undefined
            assertParamExists('foodIngredientsAdd', 'foodId', foodId)
            // verify required parameter 'createFoodIngredientsRequest' is not null or undefined
            assertParamExists('foodIngredientsAdd', 'createFoodIngredientsRequest', createFoodIngredientsRequest)
            const localVarPath = `/api/food/{foodId}/ingredients`
                .replace(`{${"foodId"}}`, encodeURIComponent(String(foodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFoodIngredientsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodIngredientsRead: async (foodId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodId' is not null or undefined
            assertParamExists('foodIngredientsRead', 'foodId', foodId)
            const localVarPath = `/api/food/{foodId}/ingredients`
                .replace(`{${"foodId"}}`, encodeURIComponent(String(foodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodIngredientsApi - functional programming interface
 * @export
 */
export const FoodIngredientsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodIngredientsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {CreateFoodIngredientsRequest} createFoodIngredientsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodIngredientsAdd(foodId: string, createFoodIngredientsRequest: CreateFoodIngredientsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodIngredientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodIngredientsAdd(foodId, createFoodIngredientsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodIngredientsApi.foodIngredientsAdd']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodIngredientsRead(foodId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodIngredientResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodIngredientsRead(foodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodIngredientsApi.foodIngredientsRead']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodIngredientsApi - factory interface
 * @export
 */
export const FoodIngredientsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodIngredientsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {CreateFoodIngredientsRequest} createFoodIngredientsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodIngredientsAdd(foodId: string, createFoodIngredientsRequest: CreateFoodIngredientsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FoodIngredientResponse>> {
            return localVarFp.foodIngredientsAdd(foodId, createFoodIngredientsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodIngredientsRead(foodId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FoodIngredientResponse>> {
            return localVarFp.foodIngredientsRead(foodId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodIngredientsApi - object-oriented interface
 * @export
 * @class FoodIngredientsApi
 * @extends {BaseAPI}
 */
export class FoodIngredientsApi extends BaseAPI {
    /**
     * 
     * @param {string} foodId The ID of the food
     * @param {CreateFoodIngredientsRequest} createFoodIngredientsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodIngredientsApi
     */
    public foodIngredientsAdd(foodId: string, createFoodIngredientsRequest: CreateFoodIngredientsRequest, options?: RawAxiosRequestConfig) {
        return FoodIngredientsApiFp(this.configuration).foodIngredientsAdd(foodId, createFoodIngredientsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} foodId The ID of the food
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodIngredientsApi
     */
    public foodIngredientsRead(foodId: string, options?: RawAxiosRequestConfig) {
        return FoodIngredientsApiFp(this.configuration).foodIngredientsRead(foodId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FoodRatingApi - axios parameter creator
 * @export
 */
export const FoodRatingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingGet: async (foodId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodId' is not null or undefined
            assertParamExists('foodRatingGet', 'foodId', foodId)
            const localVarPath = `/api/food-rating/{foodId}`
                .replace(`{${"foodId"}}`, encodeURIComponent(String(foodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingGetPersonal: async (foodId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodId' is not null or undefined
            assertParamExists('foodRatingGetPersonal', 'foodId', foodId)
            const localVarPath = `/api/food-rating/my/{foodId}`
                .replace(`{${"foodId"}}`, encodeURIComponent(String(foodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpsertRatingRequest} upsertRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingUpsert: async (upsertRatingRequest: UpsertRatingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upsertRatingRequest' is not null or undefined
            assertParamExists('foodRatingUpsert', 'upsertRatingRequest', upsertRatingRequest)
            const localVarPath = `/api/food-rating/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(upsertRatingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FoodRatingApi - functional programming interface
 * @export
 */
export const FoodRatingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FoodRatingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodRatingGet(foodId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RatingCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodRatingGet(foodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodRatingApi.foodRatingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodRatingGetPersonal(foodId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalRatingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodRatingGetPersonal(foodId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodRatingApi.foodRatingGetPersonal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpsertRatingRequest} upsertRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async foodRatingUpsert(upsertRatingRequest: UpsertRatingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PersonalRatingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.foodRatingUpsert(upsertRatingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FoodRatingApi.foodRatingUpsert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FoodRatingApi - factory interface
 * @export
 */
export const FoodRatingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FoodRatingApiFp(configuration)
    return {
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingGet(foodId: string, options?: RawAxiosRequestConfig): AxiosPromise<RatingCollectionResponse> {
            return localVarFp.foodRatingGet(foodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} foodId The ID of the food
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingGetPersonal(foodId: string, options?: RawAxiosRequestConfig): AxiosPromise<PersonalRatingResponse> {
            return localVarFp.foodRatingGetPersonal(foodId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpsertRatingRequest} upsertRatingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        foodRatingUpsert(upsertRatingRequest: UpsertRatingRequest, options?: RawAxiosRequestConfig): AxiosPromise<PersonalRatingResponse> {
            return localVarFp.foodRatingUpsert(upsertRatingRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FoodRatingApi - object-oriented interface
 * @export
 * @class FoodRatingApi
 * @extends {BaseAPI}
 */
export class FoodRatingApi extends BaseAPI {
    /**
     * 
     * @param {string} foodId The ID of the food
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodRatingApi
     */
    public foodRatingGet(foodId: string, options?: RawAxiosRequestConfig) {
        return FoodRatingApiFp(this.configuration).foodRatingGet(foodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} foodId The ID of the food
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodRatingApi
     */
    public foodRatingGetPersonal(foodId: string, options?: RawAxiosRequestConfig) {
        return FoodRatingApiFp(this.configuration).foodRatingGetPersonal(foodId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpsertRatingRequest} upsertRatingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FoodRatingApi
     */
    public foodRatingUpsert(upsertRatingRequest: UpsertRatingRequest, options?: RawAxiosRequestConfig) {
        return FoodRatingApiFp(this.configuration).foodRatingUpsert(upsertRatingRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * IngredientApi - axios parameter creator
 * @export
 */
export const IngredientApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateIngredientRequest} createIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientCreate: async (createIngredientRequest: CreateIngredientRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createIngredientRequest' is not null or undefined
            assertParamExists('ingredientCreate', 'createIngredientRequest', createIngredientRequest)
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createIngredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id The ID of the ingredient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ingredientGet', 'id', id)
            const localVarPath = `/api/ingredient/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientSearch: async (offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sorting) {
                localVarQueryParameter['sorting[]'] = sorting;
            }

            if (filter) {
                localVarQueryParameter['filter[]'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IngredientApi - functional programming interface
 * @export
 */
export const IngredientApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IngredientApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateIngredientRequest} createIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingredientCreate(createIngredientRequest: CreateIngredientRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngredientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingredientCreate(createIngredientRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngredientApi.ingredientCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id The ID of the ingredient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingredientGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngredientResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingredientGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngredientApi.ingredientGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingredientSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IngredientCollectionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingredientSearch(offset, limit, sorting, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IngredientApi.ingredientSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IngredientApi - factory interface
 * @export
 */
export const IngredientApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IngredientApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateIngredientRequest} createIngredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientCreate(createIngredientRequest: CreateIngredientRequest, options?: RawAxiosRequestConfig): AxiosPromise<IngredientResponse> {
            return localVarFp.ingredientCreate(createIngredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id The ID of the ingredient
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientGet(id: string, options?: RawAxiosRequestConfig): AxiosPromise<IngredientResponse> {
            return localVarFp.ingredientGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<Sorting>} [sorting] 
         * @param {Array<Filter>} [filter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingredientSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig): AxiosPromise<IngredientCollectionResponse> {
            return localVarFp.ingredientSearch(offset, limit, sorting, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IngredientApi - object-oriented interface
 * @export
 * @class IngredientApi
 * @extends {BaseAPI}
 */
export class IngredientApi extends BaseAPI {
    /**
     * 
     * @param {CreateIngredientRequest} createIngredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngredientApi
     */
    public ingredientCreate(createIngredientRequest: CreateIngredientRequest, options?: RawAxiosRequestConfig) {
        return IngredientApiFp(this.configuration).ingredientCreate(createIngredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id The ID of the ingredient
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngredientApi
     */
    public ingredientGet(id: string, options?: RawAxiosRequestConfig) {
        return IngredientApiFp(this.configuration).ingredientGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<Sorting>} [sorting] 
     * @param {Array<Filter>} [filter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IngredientApi
     */
    public ingredientSearch(offset?: number, limit?: number, sorting?: Array<Sorting>, filter?: Array<Filter>, options?: RawAxiosRequestConfig) {
        return IngredientApiFp(this.configuration).ingredientSearch(offset, limit, sorting, filter, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meUpdate: async (updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('meUpdate', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/api/user/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGroups: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/my-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvite: async (inviteUserRequest: InviteUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteUserRequest' is not null or undefined
            assertParamExists('userInvite', 'inviteUserRequest', inviteUserRequest)
            const localVarPath = `/api/user/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.meGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meUpdate(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meUpdate(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.meUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGroups(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGroupsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGroups(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userInvite(inviteUserRequest: InviteUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userInvite(inviteUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meGet(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.meGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meUpdate(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.meUpdate(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGroups(options?: RawAxiosRequestConfig): AxiosPromise<UserGroupsResponse> {
            return localVarFp.userGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteUserRequest} inviteUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userInvite(inviteUserRequest: InviteUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userInvite(inviteUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public meGet(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).meGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public meUpdate(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).meUpdate(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGroups(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteUserRequest} inviteUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userInvite(inviteUserRequest: InviteUserRequest, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userInvite(inviteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



